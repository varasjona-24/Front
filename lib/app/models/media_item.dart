import 'package:collection/collection.dart';
import 'package:flutter_listenfy/Modules/sources/domain/source_origin.dart';
import 'package:flutter_listenfy/Modules/sources/domain/detect_source_origin.dart';

enum MediaSource { local, youtube }

enum MediaVariantKind { audio, video }

// ============================================================================
// MediaItem
// ============================================================================

class MediaItem {
  // ============================
  // üßæ CAMPOS
  // ============================
  final String id; // interno (hash/local)
  final String publicId; // id ‚Äúestable‚Äù para backend/variantes
  final String title;
  final String subtitle;
  final MediaSource source;

  /// Thumbnail remoto (URL)
  final String? thumbnail;

  /// Thumbnail local (ruta en disco) para offline (Opci√≥n B)
  final String? thumbnailLocalPath;

  final List<MediaVariant> variants;
  final SourceOrigin origin;

  /// Favorito en UI
  final bool isFavorite;

  /// Conteo de reproducciones
  final int playCount;

  /// Timestamp (ms) √∫ltima reproducci√≥n
  final int? lastPlayedAt;

  /// Duraci√≥n base del media (si viene del backend/metadata)
  final int? durationSeconds;

  const MediaItem({
    required this.id,
    required this.publicId,
    required this.title,
    required this.subtitle,
    required this.source,
    required this.variants,
    required this.origin,
    this.thumbnail,
    this.thumbnailLocalPath,
    this.durationSeconds,
    this.isFavorite = false,
    this.playCount = 0,
    this.lastPlayedAt,
  });

  // ============================
  // üß¨ COPY WITH
  // ============================
  MediaItem copyWith({
    String? id,
    String? publicId,
    String? title,
    String? subtitle,
    MediaSource? source,
    String? thumbnail,
    String? thumbnailLocalPath,
    List<MediaVariant>? variants,
    SourceOrigin? origin,
    int? durationSeconds,
    bool? isFavorite,
    int? playCount,
    int? lastPlayedAt,
  }) {
    return MediaItem(
      id: id ?? this.id,
      publicId: publicId ?? this.publicId,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      source: source ?? this.source,
      thumbnail: thumbnail ?? this.thumbnail,
      thumbnailLocalPath: thumbnailLocalPath ?? this.thumbnailLocalPath,
      variants: variants ?? this.variants,
      origin: origin ?? this.origin,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      isFavorite: isFavorite ?? this.isFavorite,
      playCount: playCount ?? this.playCount,
      lastPlayedAt: lastPlayedAt ?? this.lastPlayedAt,
    );
  }

  // ============================
  // ‚úÖ GETTERS / ESTADO
  // ============================
  /// ID preferido para endpoints / archivos
  String get fileId => publicId.trim().isNotEmpty ? publicId.trim() : id.trim();

  bool _hasLocal(MediaVariant v) => (v.localPath?.trim().isNotEmpty ?? false);

  bool get hasAudioLocal =>
      variants.any((v) => v.kind == MediaVariantKind.audio && _hasLocal(v));

  bool get hasVideoLocal =>
      variants.any((v) => v.kind == MediaVariantKind.video && _hasLocal(v));

  MediaVariant? get localAudioVariant => variants.firstWhereOrNull(
    (v) => v.kind == MediaVariantKind.audio && _hasLocal(v),
  );

  MediaVariant? get localVideoVariant => variants.firstWhereOrNull(
    (v) => v.kind == MediaVariantKind.video && _hasLocal(v),
  );

  /// Duraci√≥n preferida (mejor: audio -> video -> item)
  int? get effectiveDurationSeconds =>
      localAudioVariant?.durationSeconds ??
      localVideoVariant?.durationSeconds ??
      durationSeconds;

  /// Indica si alguna variante est√° almacenada offline
  bool get isOfflineStored => variants.any(_hasLocal);

  /// Thumbnail preferido: local -> remoto
  String? get effectiveThumbnail {
    final lp = thumbnailLocalPath?.trim();
    if (lp != null && lp.isNotEmpty) return lp;

    final t = thumbnail?.trim();
    if (t != null && t.isNotEmpty) return t;

    return null;
  }

  /// Subtitle legible en UI: usa subtitle -> origin -> fileName
  String get displaySubtitle {
    final s = subtitle.trim();
    if (s.isNotEmpty) return s;

    if (origin != SourceOrigin.generic) return origin.key;

    final v = localAudioVariant ?? localVideoVariant ?? variants.firstOrNull;
    final name = v?.fileName.trim() ?? '';
    return name;
  }

  // ============================
  // ‚úÖ FIX CLAVE: URL / PATH reproducible
  // ============================

  /// Mejor path local disponible (audio primero, luego video)
  String? get bestLocalPath =>
      localAudioVariant?.localPath?.trim().isNotEmpty == true
      ? localAudioVariant!.localPath!.trim()
      : (localVideoVariant?.localPath?.trim().isNotEmpty == true
            ? localVideoVariant!.localPath!.trim()
            : null);

  /// Si es local: devuelve **file:///...**
  /// Si no es local: intenta usar un URL remoto si existe en la data.
  ///
  /// Importante: esto evita que el player use `fileName` como si fuese link.
  String get playableUrl {
    final lp = bestLocalPath;
    if (lp != null && lp.isNotEmpty) {
      return Uri.file(lp).toString(); // ‚úÖ aqu√≠ se arregla el "link"
    }

    // Fallback remoto (si en alg√∫n flujo `fileName` ya viene como URL)
    final anyUrl = variants
        .map((v) => v.fileName.trim())
        .firstWhereOrNull(
          (s) => s.startsWith('http://') || s.startsWith('https://'),
        );

    return anyUrl ?? '';
  }

  // ============================
  // üß© HELPERS
  // ============================
  static int? _parseDurationToSeconds(dynamic raw) {
    if (raw == null) return null;

    if (raw is num) {
      var v = raw.toInt();
      if (v > 100000) v = (v / 1000).round(); // ms -> s
      return v >= 0 ? v : null;
    }

    if (raw is String) {
      final s = raw.trim();
      if (s.isEmpty) return null;

      if (s.contains(':')) {
        final parts = s.split(':').map((p) => int.tryParse(p.trim())).toList();
        if (parts.any((e) => e == null)) return null;

        if (parts.length == 3) {
          return parts[0]! * 3600 + parts[1]! * 60 + parts[2]!;
        }
        if (parts.length == 2) {
          return parts[0]! * 60 + parts[1]!;
        }
      }

      var v = int.tryParse(s);
      if (v == null) return null;
      if (v > 100000) v = (v / 1000).round();
      return v >= 0 ? v : null;
    }

    return null;
  }

  // ============================
  // üîÅ JSON
  // ============================
  factory MediaItem.fromJson(Map<String, dynamic> json) {
    final variantsJson = (json['variants'] as List?) ?? const [];
    final variants = variantsJson
        .whereType<Map>()
        .map((m) => MediaVariant.fromJson(Map<String, dynamic>.from(m)))
        .where((v) => v.isValid)
        .toList();

    final id = (json['id'] as String?)?.trim() ?? '';
    final publicId = (json['publicId'] as String?)?.trim() ?? '';

    final titleRaw = (json['title'] as String?)?.trim();
    final title = (titleRaw != null && titleRaw.isNotEmpty)
        ? titleRaw
        : 'Unknown title';

    final subtitle =
        (json['artist'] as String?)?.trim() ??
        (json['subtitle'] as String?)?.trim() ??
        '';

    final sourceStr = (json['source'] as String?)?.toLowerCase().trim();
    final source = sourceStr == 'local'
        ? MediaSource.local
        : MediaSource.youtube;

    final durationSeconds = _parseDurationToSeconds(
      json['duration'] ??
          json['durationSeconds'] ??
          json['length'] ??
          json['lengthSeconds'],
    );

    final origin = _parseOrigin(json);
    final isFavorite = (json['isFavorite'] as bool?) ?? false;
    final playCount = (json['playCount'] as num?)?.toInt() ?? 0;
    final lastPlayedAt = (json['lastPlayedAt'] as num?)?.toInt();

    return MediaItem(
      id: id,
      publicId: publicId,
      title: title,
      subtitle: subtitle,
      source: source,
      thumbnail: (json['thumbnail'] as String?)?.trim(),
      thumbnailLocalPath: (json['thumbnailLocalPath'] as String?)?.trim(),
      variants: variants,
      durationSeconds: durationSeconds,
      origin: origin,
      isFavorite: isFavorite,
      playCount: playCount,
      lastPlayedAt: lastPlayedAt,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'publicId': publicId,
    'title': title,
    'artist': subtitle,
    'source': source == MediaSource.local ? 'local' : 'youtube',
    'origin': origin.key,
    'thumbnail': thumbnail,
    'thumbnailLocalPath': thumbnailLocalPath,
    'duration': durationSeconds,
    'isFavorite': isFavorite,
    'playCount': playCount,
    'lastPlayedAt': lastPlayedAt,
    'variants': variants.map((v) => v.toJson()).toList(),
  };
}

SourceOrigin _parseOrigin(Map<String, dynamic> json) {
  final originRaw = json['origin'] as String?;
  var origin = SourceOriginX.fromKey(originRaw);
  if (origin != SourceOrigin.generic) return origin;

  final sourceRaw = (json['source'] as String?)?.toLowerCase().trim();
  if (sourceRaw != null && sourceRaw.isNotEmpty) {
    origin = SourceOriginX.fromKey(sourceRaw);
    if (origin != SourceOrigin.generic) return origin;
  }

  final candidates = [
    json['url'],
    json['webpageUrl'],
    json['webpage_url'],
    json['sourceUrl'],
    json['source_url'],
    json['originalUrl'],
    json['original_url'],
    json['thumbnail'],
  ];

  for (final c in candidates) {
    if (c is! String) continue;
    final s = c.trim();
    if (s.isEmpty) continue;
    origin = detectSourceOriginFromUrl(s);
    if (origin != SourceOrigin.generic) return origin;
  }

  return SourceOrigin.generic;
}

// ============================================================================
// MediaVariant
// ============================================================================

class MediaVariant {
  // ============================
  // üßæ CAMPOS
  // ============================
  final MediaVariantKind kind;
  final String format;

  /// Nombre del archivo (ej: song.mp3) o en algunos flujos un URL remoto
  final String fileName;

  /// Ruta REAL del archivo en el dispositivo (picker o storage interno)
  final String? localPath;

  final int createdAt;
  final int? size;
  final int? durationSeconds;

  const MediaVariant({
    required this.kind,
    required this.format,
    required this.fileName,
    required this.createdAt,
    this.localPath,
    this.size,
    this.durationSeconds,
  });

  // ============================
  // üîÅ JSON
  // ============================
  factory MediaVariant.fromJson(Map<String, dynamic> json) {
    final fileName =
        (json['fileName'] as String?)?.trim() ??
        (json['path'] as String?)?.split('/').last.trim() ??
        '';

    final localPath = (json['localPath'] as String?)?.trim();

    final kindStr = (json['kind'] as String?)?.toLowerCase().trim();
    final kind = kindStr == 'video'
        ? MediaVariantKind.video
        : MediaVariantKind.audio;

    final format = (json['format'] as String?)?.trim() ?? '';
    final createdAt = (json['createdAt'] as num?)?.toInt() ?? 0;
    final size = (json['size'] as num?)?.toInt();

    final rawDur =
        json['durationSeconds'] ??
        json['duration'] ??
        json['lengthSeconds'] ??
        json['length'] ??
        json['durationMs'];

    final durationSeconds = MediaItem._parseDurationToSeconds(rawDur);

    return MediaVariant(
      kind: kind,
      format: format,
      fileName: fileName,
      localPath: localPath,
      createdAt: createdAt,
      size: size,
      durationSeconds: durationSeconds,
    );
  }

  Map<String, dynamic> toJson() => {
    'kind': kind == MediaVariantKind.video ? 'video' : 'audio',
    'format': format,
    'fileName': fileName,
    'localPath': localPath,
    'createdAt': createdAt,
    'size': size,
    'durationSeconds': durationSeconds,
  };

  // ============================
  // ‚úÖ VALIDACI√ìN / HELPERS
  // ============================
  bool get isValid => fileName.isNotEmpty && format.isNotEmpty;

  /// Path local ‚Äúlimpio‚Äù
  String? get playablePath {
    final lp = localPath?.trim();
    return (lp != null && lp.isNotEmpty) ? lp : null;
  }

  /// URL reproducible:
  /// - si localPath existe => file:///...
  /// - si no => si fileName ya es URL remoto => lo devuelve
  String get playableUrl {
    final lp = playablePath;
    if (lp != null) return Uri.file(lp).toString();

    final f = fileName.trim();
    if (f.startsWith('http://') || f.startsWith('https://')) return f;

    return '';
  }
}
